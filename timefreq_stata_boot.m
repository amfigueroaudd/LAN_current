function GLAN = timefreq_stata_boot(GLAN,cfg)% REALIZA BOOTSTRAPPING A TIEMPO-FRECUENCIA%% %% cfg.%  subject  = [{}{}{}]%  comp 	=[n1], 'all';  	% INDEX OF THE CONDITION,%  alpha 	=0.05;%  bl		=[ 0 0.4];	% BASELINE%  boot      = 1 %  nrandom  = 2000%  tail     = 'both', 'lower', 'upper'%  %  %  %  Pablo Billeke%%%%%%%% CONFIGURATIONStry sujetos = cfg.subject;GLAN.suject=sujetos;catch    try        sujetos = GLAN.subject;    catch    error('you must defined subject name in cfg.subject')    endend%trycond = cfg.comp;catchcond = 'all';endtrytail = cfg.tail;catchtail = 'both';end%search alphatryalpha = cfg.alpha;GLAN.timefreq.cfg.bootalpha = alpha;catch    try     alpha = GLAN.timefreq.cfg.bootalpha;    catch    alpha = 0.05;    GLAN.timefreq.cfg.bootalpha = alpha;    disp('you don'' defined the alpha, so  we used 0,05 ');    endendtry    bl = cfg.bl;    GLAN.timefreq.cfg.bl = bl;catch    try        bl = GLAN.timefreq.cfg.bl;    catch        bl= 0;        GLAN.timefreq.cfg.bl = bl;        disp('you don'' defined the baseline [cgf.bl] ');    endend    try        nrandom = cfg.nrandom;    catch        nrandom = 200;    end%%%%%%%%%%%% COMPUTATIONS % LOAD THE SUJECT'S MAT FILEfor s = 1:length(sujetos)  eval(['load  ' sujetos{s} ' ']);  eval(['LAN = ' sujetos{s} ';' ]);  LAN = lan_check(LAN);% EXTRATC DATA FOR LAN SIMPLE STRUCTURS    if s==1      if isstr(cond)      if strcmp(cond,'all')      cond = 1:lenght(LAN);      end      end    end    for c = cond        %%%%% CAMBIAR            if isfield(LAN{c}.freq,'powsptrm')                v_freq{c}(:,:,:,s) = LAN{c}.freq.powsptrm;            end                    if s == 1  %%% KEEP SPEFIFICATION FOR DEL GLAN STRUCTUR                GLAN.time = LAN{c}.time(1,:);                    GLAN.srate = LAN{c}.srate;                 GLAN.nbchan = LAN{c}.nbchan;                nbchan = LAN{c}.nbchan;                GLAN.timefreq.freq = LAN{c}.freq.freq;                GLAN.timefreq.time = LAN{c}.freq.time;               % GLAN.timefreq.cond{cond(1)} = LAN{cond(1)}.cond;               % GLAN.timefreq.cond{cond(2)} = LAN{cond(2)}.cond;                    try                    GLAN.chanlocs = GLAN{c}.chanlocs                    catch                        disp('There is not channel location file')                    end        end    end    clear LAN;    eval(['clear ' sujetos{s} ' ']);    end%%%for c = cond%%% boot per frequencymean_freq{c} = mean(v_freq{c},4);%%%if isempty(bl) | bl==0bl1=1;bl2=length(GLAN.timefreq.time) elsebl1 = find(GLAN.timefreq.time>=bl(1),1,'first');bl2 = find(GLAN.timefreq.time>bl(2),1,'first')-1;lbl = length([bl1:bl2]);end[ff elec tt ss]=size(v_freq{c});P = zeros(ff,elec,tt);indexboot = fix(rand(nrandom,ss) .* ss) +1;indexboot(indexboot>ss) = ss;indexboott = fix(rand(nrandom,lbl) .* lbl) +bl1;indexboott(indexboott>lbl) = lbl;for ee = 1:elec    %A = zeros(ff,1,lbl,ss);    %B =[];    for nr = 1:nrandom      C = squeeze(mean(mean(v_freq{c}(:,ee,indexboott(nr,:), indexboot(nr,:)),4),3));      B = squeeze(mean_freq{c}(:,elec,:)) > repmat(C,1,tt);      P(:,elec,:) = P(:,elec,:) + permute(B,[1,3,2]);      %B = squeeze(mean_freq{c}(:,elec,:)) < repmat(C,1,tt);      %P(:,elec,:) = P(:,elec,:) + (permute(B,[1,3,2]).*-1);      clear C B    endendP = P ./ nrandom;end %%%% for c = condhh = zeros(size(P));pp=zeros(size(P));GLAN.timefreq.data = mean_freq;if strcmp(tail,'both')    alpha = alpha/2;    hh(P > (1-alpha)) = 1;    hh(P < (alpha)) = 1;    GLAN.timefreq.boothh = hh;    pp(P > 0.5) = P(P > 0.5)-1;    pp(P < 0.5) = P(P < 0.5);    GLAN.timefreq.bootp = pp;elseif strcmp(tail,'upper')    GLAN.timefreq.boothh = P > (1-alpha);    GLAN.timefreq.bootp = P-1;elseif strcmp(tail,'lower')    GLAN.timefreq.boothh = P < alpha;    GLAN.timefreq.bootp = P;end